#{{{ General

[[plugins]]
repo = 'Shougo/dein.vim'

#{{{ config
[[plugins]]
repo = 'Shougo/context_filetype.vim'

[[plugins]]
repo = 'editorconfig/editorconfig-vim'
#}}}

#{{{ fmt
[[plugins]]
repo = 'sbdchd/neoformat'
hook_add = '''
augroup neoformat
    autocmd!
    autocmd FileType java autocmd! neoformat BufWritePre * undojoin | Neoformat
augroup END
'''
build = '''
brew install astyle
'''
#}}}

#{{{ temporary filetype
[[plugins]]
repo = 'osyo-manga/vim-precious'
#}}}

#{{{ Status bar
# color scheme for lightline
[[plugins]]
repo = 'cocopon/lightline-hybrid.vim'
depends = 'vim-hybrid'

[[plugins]]
repo = 'itchyny/lightline.vim'
hook_add = '''
    let g:lightline = {
                \ 'colorscheme': 'hybrid',
                \ 'mode_map': { 'c': 'NORMAL' },
                \ 'active': {
                \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ] ],
                \   'right': [ [ 'ale', 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
                \ },
                \ 'component_function': {
                \   'fugitive': 'LightLineFugitive',
                \   'filename': 'LightLineFilename',
                \   'fileformat': 'LightLineFileformat',
                \   'filetype': 'LightLineFiletype',
                \   'fileencoding': 'LightLineFileencoding',
                \   'mode': 'LightLineMode',
                \ },
                \ 'component_expand': {
                \   'ale': 'ALEStatus',
                \ },
                \ 'component_type': {
                \   'ale': 'error',
                \ },
                \ 'subseparator': { 'left': '|', 'right': '|' }
                \ }

    function! LightLineModified()
        return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
    endfunction

    function! LightLineReadonly()
        return &ft !~? 'help' && &readonly ? 'RO' : ''
    endfunction

    function! LightLineFilename()
        let fname = expand('%:t')
        return fname == 'ControlP' ? g:lightline.ctrlp_item :
                    \ fname == '__Tagbar__' ? g:lightline.fname :
                    \ fname =~ '__Gundo\|NERD_tree' ? '' :
                    \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
                    \ &ft == 'unite' ? unite#get_status_string() :
                    \ &ft == 'vimshell' ? vimshell#get_status_string() :
                    \ ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
                    \ ('' != fname ? fname : '[No Name]') .
                    \ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
    endfunction

    function! LightLineFugitive()
        try
            if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
                let mark = ''  " edit here for cool mark
                let _ = fugitive#head()
                return strlen(_) ? mark._ : ''
            endif
        catch
        endtry
        return ''
    endfunction

    function! LightLineFileformat()
        return winwidth(0) > 70 ? &fileformat : ''
    endfunction

    function! LightLineFiletype()
        return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
    endfunction

    function! LightLineFileencoding()
        return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
    endfunction

    function! LightLineMode()
        let fname = expand('%:t')
        return fname == '__Tagbar__' ? 'Tagbar' :
                    \ fname == 'ControlP' ? 'CtrlP' :
                    \ fname == '__Gundo__' ? 'Gundo' :
                    \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
                    \ fname =~ 'NERD_tree' ? 'NERDTree' :
                    \ &ft == 'unite' ? 'Unite' :
                    \ &ft == 'vimfiler' ? 'VimFiler' :
                    \ &ft == 'vimshell' ? 'VimShell' :
                    \ winwidth(0) > 60 ? lightline#mode() : ''
    endfunction

    let g:tagbar_status_func = 'TagbarStatusFunc'

    function! TagbarStatusFunc(current, sort, fname, ...) abort
        let g:lightline.fname = a:fname
        return lightline#statusline(0)
    endfunction

    function! ALEStatus()
        return '%{ale#statusline#Status()}'
    endfunction

    let g:unite_force_overwrite_statusline = 0
    let g:vimfiler_force_overwrite_statusline = 0
    let g:vimshell_force_overwrite_statusline = 0
'''
#}}}

#{{{ history
[[plugins]]
repo = 'simnalamburt/vim-mundo'
hook_add = '''
    let g:mundo_prefer_python3 = 1
    nnoremap <space>u :<C-u>MundoToggle<CR>
'''
#}}}

#{{{ content
[[plugins]]
repo = 'vim-scripts/diffchar.vim'
hook_add = '''
    let g:DiffUnit = "Word1"
'''
#}}}

#}}}

#{{{ Color Scheme
[[plugins]]
repo = 'w0ng/vim-hybrid'
hook_add = '''
    let g:hybrid_custom_term_colors = 1
    " let g:hybrid_reduced_contrast = 1
    set background=dark
    augroup colorscheme_hybrid
      autocmd!
      autocmd VimEnter * nested colorscheme hybrid
    augroup END
'''
#}}}

#{{{ Programming

#{{{ Filer
[[plugins]]
repo = 'scrooloose/nerdtree'
hook_add = '''
    nnoremap <silent> <space>e :<C-u>NERDTreeToggle<CR>
    let g:NERDTreeMinimalUI=1
    let g:NERDTreeShowHidden=1
    let g:NERDTreeDirArrowExpandable = '▸'
    let g:NERDTreeDirArrowCollapsible = '▾'
'''
#}}}

#{{{ Editor
[[plugins]] # edit surround easy
repo = 'tpope/vim-surround'

[[plugins]] # Aligning Text
repo = 'junegunn/vim-easy-align'
hook_add = '''
    " Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
    vmap <Enter> <Plug>(EasyAlign)

    " Start interactive EasyAlign for a motion/text object (e.g. gaip)
    nmap ga <Plug>(EasyAlign)

    if !exists('g:easy_align_delimiters')
        let g:easy_align_delimiters = {}
    endif
    let g:easy_align_delimiters['"'] = {
                \ 'pattern': '"',
                \ 'ignore_groups': ['!Comment']
                \ }
'''

[[plugins]] # comment stuff out
repo = 'tpope/vim-commentary'

[[plugins]] # easily search for, substitute, and abbreviate multiple variants of a word
repo = 'tpope/vim-abolish'
#}}}

#{{{ Motion
[[plugins]] # highlight substitute target
repo = 'osyo-manga/vim-over'
hook_add = '''
    nnoremap <silent> <Leader>s :<C-u>OverCommandLine<CR>
'''

[[plugins]] # pairs of handy bracket mappings
repo = 'tpope/vim-unimpaired'
#}}}

#{{{ syntax check
[[plugins]] # syntax check
repo = 'w0rp/ale'
hook_add = '''
    let g:ale_lint_on_enter = 0
    let g:ale_lint_on_save = 1
    let g:ale_lint_on_text_changed = 0
    let g:ale_echo_msg_format = '[%linter%] %s (%severity%)'
    let g:ale_statusline_format = ['E%d', 'W%d', '']

    let g:ale_linters = {
                \ 'go': [
                    \ 'go build',
                    \ 'gofmt',
                    \ 'gosimple',
                    \ 'go vet',
                    \ 'staticcheck'
                    \ ],
                \ 'html': [
                    \ 'htmlhint'
                    \ ]
                \ }
'''

[[plugins]]
repo = 'osyo-manga/shabadou.vim'

[[plugins]]
repo = 'Shougo/vimproc.vim'
build = 'make'

[[plugins]]
repo = 'cohama/vim-hier'

[[plugins]]
repo = 'dannyob/quickfixstatus'
#}}}

#{{{ Git/Gist
[[plugins]]
repo = 'tpope/vim-fugitive'

[[plugins]]
repo = 'tpope/vim-rhubarb'

[[plugins]]
repo = 'airblade/vim-gitgutter'

[[plugins]]
repo = 'cohama/agit.vim'

[[plugins]]
repo = 'idanarye/vim-merginal'
#}}}

#}}}

#{{{ Misc
[[plugins]] # the_silver_searcher
repo = 'rking/ag.vim'

[[plugins]] # replacement in quickfix
repo = 'thinca/vim-qfreplace'

[[plugins]] # quickrun
repo = 'thinca/vim-quickrun'
hook_add = '''
    let g:quickrun_config = get(g:, 'quickrun_config', {})
    let g:quickrun_config._ = {
                \ 'runner': 'vimproc',
                \ 'runner/vimproc/updatetime': 40,
                \ }
    let g:quickrun_config.html = {
                \ 'outputter': 'browser'
                \ }
'''

[[plugins]] # qargs
repo = 'henrik/vim-qargs'

[[plugins]] # list tags
repo = 'majutsushi/tagbar'
build = 'brew install ctags'
hook_add = '''
    nmap <space>t :<C-u>TagbarToggle<CR>
'''

# memo
[[plugins]]
repo = 'fuenor/qfixgrep'
hook_add = '''
    let QFixWin_EnableMode = 0
'''

[[plugins]]
repo = 'glidenote/memolist.vim'
depends = 'qfixgrep'
hook_add = '''
    let g:memolist_path = "~/Dropbox/memo"
    " suffix type (default markdown)
    let g:memolist_memo_suffix = "txt"

    " date format (default %Y-%m-%d %H:%M)
    let g:memolist_memo_date = "%Y-%m-%d %H:%M"
    "" let g:memolist_memo_date = "epoch"
    "" let g:memolist_memo_date = "%D %T"

    " tags prompt (default 0)
    "" let g:memolist_prompt_tags = 1

    " categories prompt (default 0)
    let g:memolist_prompt_categories = 1

    " use qfixgrep (default 0)
    let g:memolist_qfixgrep = 1

    " use vimfler (default 0)
    "" let g:memolist_vimfiler = 1

    " use arbitrary vimfler option (default -split -winwidth=50)
    "" let g:memolist_vimfiler_option = "-split -winwidth=50 -simple"

    " use unite (default 0)
    "" let g:memolist_unite = 1

    " use arbitrary unite option (default is empty)
    "" let g:memolist_unite_option = "-auto-preview -start-insert"

    " use arbitrary unite source (default is 'file')
    "" let g:memolist_unite_source = "file_rec"

    " use template
    let g:memolist_template_dir_path = "~/.vim/template/memolist"

    " remove filename prefix (default 0)
    "" let g:memolist_filename_prefix_none = 1

    " use various Ex commands (default '')
    let g:memolist_ex_cmd = 'NERDTree'

    nnoremap <Leader>mn :<C-u>MemoNew<CR>
    nnoremap <Leader>ml :<C-u>MemoList<CR>
    nnoremap <Leader>mg :<C-u>MemoGrep<CR>
    " use CtrlP
    nnoremap <Leader>mf :<C-u>exe "CtrlP" g:memolist_path<cr><f5>
'''

[[plugins]] # use histogram algorithm for vimdiff
repo = 'chrisbra/vim-diff-enhanced'
hook_add = '''
    let &diffexpr='EnhancedDiff#Diff("git diff", "--diff-algorithm=histogram")'
'''

[[plugins]]
repo = 'AndrewRadev/linediff.vim'

[[plugins]] # switch between a single-line statement and a multi-line one
repo = 'AndrewRadev/splitjoin.vim'

[[plugins]]
repo = 'itchyny/calendar.vim'
hook_add = '''
    let g:calendar_google_calendar = 1
    let g:calendar_google_task = 1
    let g:calendar_frame = 'default'
    let g:calendar_first_day = 'monday'
'''

#}}}
