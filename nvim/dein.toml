#{{{ General

[[plugins]]
repo = 'Shougo/dein.vim'

#{{{ config
[[plugins]]
repo = 'Shougo/context_filetype.vim'
#}}}

#{{{ temporary filetype
[[plugins]]
repo = 'osyo-manga/vim-precious'
#}}}

#{{{ Status bar
# color scheme for lightline
[[plugins]]
repo = 'cocopon/lightline-hybrid.vim'
depends = 'vim-hybrid'

[[plugins]]
repo = 'itchyny/lightline.vim'
hook_add = '''
    let g:lightline = {
                \ 'colorscheme': 'hybrid',
                \ 'mode_map': { 'c': 'NORMAL' },
                \ 'active': {
                \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ] ],
                \   'right': [ [ 'neomake', 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
                \ },
                \ 'component_function': {
                \   'fugitive': 'LightLineFugitive',
                \   'filename': 'LightLineFilename',
                \   'fileformat': 'LightLineFileformat',
                \   'filetype': 'LightLineFiletype',
                \   'fileencoding': 'LightLineFileencoding',
                \   'mode': 'LightLineMode',
                \ },
                \ 'component_expand': {
                \   'neomake': 'LightlineNeomake',
                \ },
                \ 'component_type': {
                \   'neomake': 'error',
                \ },
                \ 'subseparator': { 'left': '|', 'right': '|' }
                \ }

    function! LightLineModified()
        return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
    endfunction

    function! LightLineReadonly()
        return &ft !~? 'help' && &readonly ? 'RO' : ''
    endfunction

    function! LightLineFilename()
        let fname = expand('%:t')
        return fname == 'ControlP' ? g:lightline.ctrlp_item :
                    \ fname == '__Tagbar__' ? g:lightline.fname :
                    \ fname =~ '__Gundo\|NERD_tree' ? '' :
                    \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
                    \ &ft == 'unite' ? unite#get_status_string() :
                    \ &ft == 'vimshell' ? vimshell#get_status_string() :
                    \ ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
                    \ ('' != fname ? fname : '[No Name]') .
                    \ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
    endfunction

    function! LightLineFugitive()
        try
            if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
                let mark = ''  " edit here for cool mark
                let _ = fugitive#head()
                return strlen(_) ? mark._ : ''
            endif
        catch
        endtry
        return ''
    endfunction

    function! LightLineFileformat()
        return winwidth(0) > 70 ? &fileformat : ''
    endfunction

    function! LightLineFiletype()
        return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
    endfunction

    function! LightLineFileencoding()
        return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
    endfunction

    function! LightLineMode()
        let fname = expand('%:t')
        return fname == '__Tagbar__' ? 'Tagbar' :
                    \ fname == 'ControlP' ? 'CtrlP' :
                    \ fname == '__Gundo__' ? 'Gundo' :
                    \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
                    \ fname =~ 'NERD_tree' ? 'NERDTree' :
                    \ &ft == 'unite' ? 'Unite' :
                    \ &ft == 'vimfiler' ? 'VimFiler' :
                    \ &ft == 'vimshell' ? 'VimShell' :
                    \ winwidth(0) > 60 ? lightline#mode() : ''
    endfunction

    let g:tagbar_status_func = 'TagbarStatusFunc'

    function! TagbarStatusFunc(current, sort, fname, ...) abort
        let g:lightline.fname = a:fname
        return lightline#statusline(0)
    endfunction

    function! LightlineNeomake()
        return '%{neomake#statusline#LoclistStatus()}'
    endfunction

    let g:unite_force_overwrite_statusline = 0
    let g:vimfiler_force_overwrite_statusline = 0
    let g:vimshell_force_overwrite_statusline = 0
'''
#}}}

#{{{ history
[[plugins]]
repo = 'simnalamburt/vim-mundo'
hook_add = '''
    let g:mundo_prefer_python3 = 1
    nnoremap <space>u :<C-u>MundoToggle<CR>
'''
#}}}

#{{{ content
[[plugins]]
repo = 'vim-scripts/diffchar.vim'
hook_add = '''
    let g:DiffUnit = "Word1"
'''
#}}}

#}}}

#{{{ Color Scheme
[[plugins]]
repo = 'w0ng/vim-hybrid'
hook_add = '''
    let g:hybrid_use_Xresources = 1
    set background=dark
    augroup colorscheme_hybrid
      autocmd!
      autocmd VimEnter * nested colorscheme hybrid
    augroup END
'''
#}}}

#{{{ Programming

#{{{ deoplete
# for deoplete
[[plugins]]
repo = 'Shougo/echodoc.vim'
hook_add = '''
    let g:echodoc_enable_at_startup = 1
'''
#}}}

#{{{ Filer
[[plugins]]
repo = 'scrooloose/nerdtree'
hook_add = '''
    nnoremap <silent> <space>e :<C-u>NERDTreeToggle<CR>
    let g:NERDTreeMinimalUI=1
    let g:NERDTreeShowHidden=1
    let g:NERDTreeDirArrowExpandable = '▸'
    let g:NERDTreeDirArrowCollapsible = '▾'
'''
#}}}

#{{{ Editor
[[plugins]] # edit surround easy
repo = 'tpope/vim-surround'

[[plugins]] # Aligning Text
repo = 'junegunn/vim-easy-align'
hook_add = '''
    " Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
    vmap <Enter> <Plug>(EasyAlign)

    " Start interactive EasyAlign for a motion/text object (e.g. gaip)
    nmap ga <Plug>(EasyAlign)

    if !exists('g:easy_align_delimiters')
        let g:easy_align_delimiters = {}
    endif
    let g:easy_align_delimiters['"'] = {
                \ 'pattern': '"',
                \ 'ignore_groups': ['!Comment']
                \ }
'''

[[plugins]] # comment stuff out
repo = 'tpope/vim-commentary'

[[plugins]] # easily search for, substitute, and abbreviate multiple variants of a word
repo = 'tpope/vim-abolish'
#}}}

#{{{ Motion
[[plugins]]
repo = 'Lokaltog/vim-easymotion'
hook_add = '''
    " based on [Vim-EasyMotionでカーソル移動を爆速にして生産性をもっと向上させる - haya14busa](http://haya14busa.com/mastering-vim-easymotion/)
    " =======================================
    " Boost your productivity with EasyMotion
    " =======================================
    " Disable default mappings
    " If you are true vimmer, you should explicitly map keys by yourself.
    " Do not rely on default bidings.
    let g:EasyMotion_do_mapping = 0

    " Or map prefix key at least(Default: <Leader><Leader>)
    " map <Leader> <Plug>(easymotion-prefix)

    " =======================================
    " Find Motions
    " =======================================
    " Jump to anywhere you want by just `4` or `3` key strokes without thinking!
    " `s{char}{char}{target}`
    nmap s <Plug>(easymotion-s2)
    xmap s <Plug>(easymotion-s2)
    omap z <Plug>(easymotion-s2)
    " Of course, you can map to any key you want such as `<Space>`
    " map <Space>(easymotion-s2)

    " Turn on case sensitive feature
    let g:EasyMotion_smartcase = 1

    " =======================================
    " Line Motions
    " =======================================
    " `JK` Motions: Extend line motions
    map <Leader>j <Plug>(easymotion-j)
    map <Leader>k <Plug>(easymotion-k)
    " keep cursor column with `JK` motions
    let g:EasyMotion_startofline = 0

    " =======================================
    " General Configuration
    " =======================================
    let g:EasyMotion_keys = ';HKLYUIOPNM,QWERTASDGZXCVBJF'
    " Show target key with upper case to improve readability
    let g:EasyMotion_use_upper = 1
    " Jump to first match with enter & space
    let g:EasyMotion_enter_jump_first = 1
    let g:EasyMotion_space_jump_first = 1
    let g:EasyMotion_use_migemo = 1


    " =======================================
    " Search Motions
    " =======================================
    " Extend search motions with vital-over command line interface
    " Incremental highlight of all the matches
    " Now, you don't need to repetitively press `n` or `N` with EasyMotion feature
    " `<Tab>` & `<S-Tab>` to scroll up/down a page with next match
    " :h easymotion-command-line
    nmap g/ <Plug>(easymotion-sn)
    xmap g/ <Plug>(easymotion-sn)
    omap g/ <Plug>(easymotion-tn)
'''

[[plugins]] # highlight substitute target
repo = 'osyo-manga/vim-over'
hook_add = '''
    nnoremap <silent> <Leader>s :<C-u>OverCommandLine<CR>
'''

[[plugins]] # pairs of handy bracket mappings
repo = 'tpope/vim-unimpaired'
#}}}

#{{{ syntax check
[[plugins]] # syntax check
repo = 'neomake/neomake'
hook_add = '''
    autocmd! BufWritePost * Neomake
'''

[[plugins]]
repo = 'osyo-manga/shabadou.vim'

[[plugins]]
repo = 'Shougo/vimproc.vim'
build = 'make'

[[plugins]]
repo = 'cohama/vim-hier'

[[plugins]]
repo = 'dannyob/quickfixstatus'
#}}}

#{{{ Git/Gist
[[plugins]]
repo = 'tpope/vim-fugitive'

[[plugins]]
repo = 'airblade/vim-gitgutter'

[[plugins]]
repo = 'cohama/agit.vim'

[[plugins]]
repo = 'idanarye/vim-merginal'
#}}}

#}}}

#{{{ Misc
[[plugins]] # the_silver_searcher
repo = 'rking/ag.vim'

[[plugins]] # replacement in quickfix
repo = 'thinca/vim-qfreplace'

[[plugins]] # quickrun
repo = 'thinca/vim-quickrun'
hook_add = '''
    let g:quickrun_config = get(g:, 'quickrun_config', {})
    let g:quickrun_config._ = {
                \ 'runner': 'vimproc',
                \ 'runner/vimproc/updatetime': 40,
                \ }
'''

[[plugins]] # qargs
repo = 'henrik/vim-qargs'

[[plugins]] # list tags
repo = 'majutsushi/tagbar'
build = 'brew install ctags'
hook_add = '''
    nmap <space>t :<C-u>TagbarToggle<CR>
'''

# memo
[[plugins]]
repo = 'fuenor/qfixgrep'

[[plugins]]
repo = 'glidenote/memolist.vim'
depends = 'qfixgrep'
hook_add = '''
    let g:memolist_path = "~/Dropbox/memo"
    " suffix type (default markdown)
    let g:memolist_memo_suffix = "txt"

    " date format (default %Y-%m-%d %H:%M)
    let g:memolist_memo_date = "%Y-%m-%d %H:%M"
    "" let g:memolist_memo_date = "epoch"
    "" let g:memolist_memo_date = "%D %T"

    " tags prompt (default 0)
    "" let g:memolist_prompt_tags = 1

    " categories prompt (default 0)
    let g:memolist_prompt_categories = 1

    " use qfixgrep (default 0)
    let g:memolist_qfixgrep = 1

    " use vimfler (default 0)
    "" let g:memolist_vimfiler = 1

    " use arbitrary vimfler option (default -split -winwidth=50)
    "" let g:memolist_vimfiler_option = "-split -winwidth=50 -simple"

    " use unite (default 0)
    "" let g:memolist_unite = 1

    " use arbitrary unite option (default is empty)
    "" let g:memolist_unite_option = "-auto-preview -start-insert"

    " use arbitrary unite source (default is 'file')
    "" let g:memolist_unite_source = "file_rec"

    " use template
    let g:memolist_template_dir_path = "~/.vim/template/memolist"

    " remove filename prefix (default 0)
    "" let g:memolist_filename_prefix_none = 1

    " use various Ex commands (default '')
    let g:memolist_ex_cmd = 'NERDTree'

    nnoremap <Leader>mn :<C-u>MemoNew<CR>
    nnoremap <Leader>ml :<C-u>MemoList<CR>
    nnoremap <Leader>mg :<C-u>MemoGrep<CR>
    " use CtrlP
    nnoremap <Leader>mf :<C-u>exe "CtrlP" g:memolist_path<cr><f5>
'''

[[plugins]] # use histogram algorithm for vimdiff
repo = 'chrisbra/vim-diff-enhanced'
hook_add = '''
    let &diffexpr='EnhancedDiff#Diff("git diff", "--diff-algorithm=histogram")'
'''
#}}}
