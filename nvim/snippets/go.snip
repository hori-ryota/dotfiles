snippet main
abbr    "init main and Main"
options head
  package main

  import (
    "log"
    "os"
  )

  func main() {
    if err := Main(os.Args); err != nil {
      log.Fatal(err)
    }
  }

  func Main(args []string) error {
    ${0:TARGET}
    return nil
  }

snippet ctx
abbr    "arg context"
options word
  ctx context.Context

snippet ctxb
abbr    "context.Background()"
options word
  context.Background()

snippet ctxt
abbr    "context.TODO()"
options word
  context.TODO()

snippet ife
abbr    "if err != nil {}"
options head
  if err != nil {
    ${0:TARGET}
  }

snippet ifer
abbr    "if err != nil {}"
options head
  if err != nil {
    return ${0}
  }

snippet ifee
abbr    "if err := ${1:TARGET}; err != nil {}"
options head
  if err := ${1:TARGET}; err != nil {
    ${0}
  }

snippet ife_
abbr    "if _, err := ${1:TARGET}; err != nil {}"
options head
  if _, err := ${1:TARGET}; err != nil {
    ${0}
  }

snippet r
abbr "return"
options word
  return ${0:TARGET}

snippet test
abbr "test"
options head
alias t
  func Test${1}(t *testing.T) {
    ${0}
  }

snippet tt
abbr "subtest"
options head
  t.Run("${1}", func(t *testing.T) {
    ${0:TARGET}
  })

snippet ttr
abbr "range subtest"
options head
  for _, tt := range []struct{
    name string
    ${1:want} ${2:string}
  }{
    {
      name: "${3}",
      $1: ${4},
    },
  }{
    tt := tt
    t.Run(tt.name, func(t *testing.T) {
      ${0:TARGET}
    })
  }

snippet mc
abbr "initialize gomock controller"
options head
  ctrl, ctx := gomock.WithContext(context.Background(), t)
  defer ctrl.Finish()
  ${0}

snippet mockgen
abbr "common mockgen command"
options head
  //go:generate mockgen -source $GOFILE -destination mock_$GOPACKAGE/${GOFILE}_mock.go

snippet eww
abbr "zaperr.WrapperWith"
options head
  zaperr ${1}= zaperr.WrapperWith(zap.${0})

snippet ew
abbr "zaperr.Wrap"
options word
  zaperr.Wrap(err, "${0}")

snippet en
abbr "zaperr.New"
options word
  zaperr.New("${0}")

snippet pn
abbr "panic by not implemented"
options head
  panic("not implemented")

snippet h
abbr "handler with register"
options head
  func (${1:y} `getreg('h')`) ${2}(${3}) (${4}) {
    ${0:TARGET:panic("not implemented")}
  }

snippet hp
abbr "handler with register (pointer handler)"
options head
  func (${1:y} *`getreg('h')`) ${2}(${3}) (${4}) {
    ${0:TARGET:panic("not implemented")}
  }

snippet rt
abbr "required tag"
options word
  required:""

snippet rtt
abbr "required tag with backquote"
options word
  \`required:""\`

snippet gt
abbr "getter tag"
options word
  getter:""

snippet gtt
abbr "getter tag with backquote"
options word
  \`getter:""\`

snippet st
abbr "setter tag"
options word
  setter:""

snippet stt
abbr "setter tag with backquote"
options word
  \`setter:""\`

snippet gst
abbr "getter setter tag"
options word
  getter:"" setter:""

snippet gstt
abbr "getter setter tag with backquote"
options word
  \`getter:"" setter:""\`

snippet rgst
abbr "required getter setter tag"
options word
  required:"" getter:"" setter:""

snippet rgstt
abbr "required getter setter tag with backquote"
options word
  \`required:"" getter:"" setter:""\`

snippet rgt
abbr "required getter tag"
options word
  required:"" getter:""

snippet rgtt
abbr "required getter tag with backquote"
options word
  \`required:"" getter:""\`

snippet rst
abbr "required setter tag"
options word
  required:"" setter:""

snippet rstt
abbr "required setter tag with backquote"
options word
  \`required:"" setter:""\`

snippet gcm
abbr "gencontructor mark"
options word
  //genconstructor

snippet ggc
abbr "//go:generate go-genconstructor"
options head
  //go:generate go-codegen go_constructor

snippet gga
abbr "//go:generate go-genaccessor"
options head
  //go:generate go-codegen go_accessor

snippet uio
abbr "Usecase"
options head
  //genconstructor
  type ${1}Usecase struct {
    authorizer $1UsecaseAuthorizer \`required:""\`
  }

  //genconstructor
  type $1UsecaseInput struct {
    ${3}
  }

  //genconstructor
  type $1UsecaseOutput struct {
    ${4}
  }

  func (u $1Usecase) ${2}(
    ctx context.Context,
    input $1UsecaseInput,
    actor Actor,
  ) ($1UsecaseOutput, domain.Error) {
    if err := u.authorizer.AuthorizeActorTo$2(ctx, input, actor); err != nil {
      return $1UsecaseOutput{}, err
    }
    ${0}
    return $1UsecaseOutput{}, nil
  }

  type $1UsecaseAuthorizer interface {
    AuthorizeActorTo$2(context.Context, $1UsecaseInput, Actor) domain.Error
  }

snippet ui
abbr "Usecase only input"
options head
  //genconstructor
  type ${1}Usecase struct {
    authorizer $1UsecaseAuthorizer \`required:""\`
  }

  //genconstructor
  type $1UsecaseInput struct {
    ${3}
  }

  func (u $1Usecase) ${2}(
    ctx context.Context,
    input $1UsecaseInput,
    actor Actor,
  ) domain.Error {
    if err := u.authorizer.AuthorizeActorTo$2(ctx, input, actor); err != nil {
      return err
    }
    ${0}
    return nil
  }

  type $1UsecaseAuthorizer interface {
    AuthorizeActorTo$2(context.Context, $1UsecaseInput, Actor) domain.Error
  }

snippet uo
abbr "Usecase only output"
options head
  //genconstructor
  type ${1}Usecase struct {
    authorizer $1UsecaseAuthorizer \`required:""\`
  }

  //genconstructor
  type $1UsecaseOutput struct {
    ${3}
  }

  func (u $1Usecase) ${2}(
    ctx context.Context,
    actor Actor,
  ) ($1UsecaseOutput, domain.Error) {
    if err := u.authorizer.AuthorizeActorTo$2(ctx, actor); err != nil {
      return $1UsecaseOutput{}, err
    }
    ${0}
    return $1UsecaseOutput{}, nil
  }

  type $1UsecaseAuthorizer interface {
    AuthorizeActorTo$2(context.Context, Actor) domain.Error
  }

snippet u
abbr "Usecase without input and output"
options head
  //genconstructor
  type ${1}Usecase struct {
    authorizer $1UsecaseAuthorizer \`required:""\`
  }

  func (u $1Usecase) ${2}(
    ctx context.Context,
    actor Actor,
  ) domain.Error {
    if err := u.authorizer.AuthorizeActorTo$2(ctx, actor); err != nil {
      return err
    }
    ${0}
    return nil
  }

  type $1UsecaseAuthorizer interface {
    AuthorizeActorTo$2(context.Context, Actor) domain.Error
  }
